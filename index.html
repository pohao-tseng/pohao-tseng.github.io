<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PO-HAO TSENG | 意義場 V3</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>
    <style>
        :root {
            --bg-color: #000000;
            --text-color: #f0f0f0;
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: var(--bg-color);
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
            color: var(--text-color);
        }

        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        #ui-layer {
            position: relative;
            z-index: 10;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .interactive {
            pointer-events: auto;
        }

        /* Landing Screen */
        #landing-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            /* 讓背景更深邃 */
            background: radial-gradient(circle, rgba(0,0,0,0) 0%, rgba(0,0,0,0.9) 100%);
        }

        h1 {
            font-weight: 100;
            letter-spacing: 12px;
            font-size: 1.1rem;
            margin-bottom: 4rem;
            text-transform: uppercase;
            color: rgba(255,255,255,0.9);
            text-shadow: 0 0 10px rgba(255,255,255,0.3);
        }

        #enter-btn {
            background: transparent;
            border: none;
            color: rgba(255,255,255,0.7);
            padding: 20px;
            font-size: 0.9rem;
            cursor: pointer;
            letter-spacing: 4px;
            position: relative;
            overflow: hidden;
            transition: color 0.3s;
        }
        
        #enter-btn::after {
            content: '';
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 1px;
            background: rgba(255,255,255,0.5);
            transition: width 0.5s ease;
        }

        #enter-btn:hover {
            color: #fff;
            text-shadow: 0 0 8px rgba(255,255,255,0.5);
        }

        #enter-btn:hover::after {
            width: 50%;
        }

        /* Navigation - 極簡化 */
        nav {
            position: absolute;
            top: 40px;
            right: 50px;
            display: flex;
            flex-direction: column; /* 改為垂直排列，更有現代感 */
            gap: 15px;
            opacity: 0;
            transform: translateX(20px);
        }

        .nav-link {
            text-decoration: none;
            color: #555;
            font-size: 0.8rem;
            letter-spacing: 2px;
            text-align: right;
            cursor: pointer;
            transition: all 0.5s;
        }

        .nav-link:hover, .nav-link.active {
            color: #fff;
            transform: translateX(-10px);
            text-shadow: 0 0 5px rgba(255,255,255,0.5);
        }

        /* Content */
        .content-section {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            opacity: 0;
        }
        
        .content-section.active {
            display: block;
        }

        .content-inner {
            position: absolute;
            bottom: 10%; /* 文字沉在下方，讓上方留給視覺 */
            left: 10%;
            width: 50%;
            max-width: 600px;
        }

        .text-block h2 {
            font-weight: 200;
            font-size: 1.8rem;
            margin-bottom: 20px;
            color: #fff;
            letter-spacing: 3px;
        }

        .text-block p {
            line-height: 1.8;
            font-size: 0.9rem;
            color: #bbb;
            margin-bottom: 15px;
            text-align: justify;
        }

        /* 手機適配 */
        @media (max-width: 768px) {
            .content-inner {
                width: 85%;
                bottom: 15%;
            }
            nav {
                flex-direction: row;
                top: auto;
                bottom: 30px;
                right: 0;
                width: 100%;
                justify-content: center;
                gap: 25px;
            }
        }
    </style>
</head>
<body>

    <div id="canvas-container"></div>

    <div id="ui-layer">
        <div id="landing-screen" class="interactive">
            <h1>PO-HAO TSENG</h1>
            <button id="enter-btn">ENTER / 進入</button>
        </div>

        <nav id="main-nav" class="interactive">
            <a class="nav-link" onclick="navigateTo('about')">ABOUT</a>
            <a class="nav-link" onclick="navigateTo('experiences')">EXPERIENCES</a>
            <a class="nav-link" onclick="navigateTo('gallery')">GALLERY</a>
        </nav>

        <div id="about" class="content-section interactive">
            <div class="content-inner">
                <div class="text-block">
                    <h2>意義場</h2>
                    <p>這不是一個固定的空間，而是一個持續生成的過程。</p>
                    <p>在這裡，脈絡是流動的，如同這些粒子。每一個瞬間的交會都產生了暫時的結構，但隨即消散，重組為新的意義。</p>
                </div>
            </div>
        </div>

        <div id="experiences" class="content-section interactive">
            <div class="content-inner">
                <div class="text-block">
                    <h2>經歷路徑</h2>
                    <p>2026 | 結構測試 - 台北</p>
                    <p>2025 | 湧現的邊界 - 台南藝術節</p>
                    <p>2023 | 駐村 - 巴黎西帖</p>
                    <p>（更多時間軸資料...）</p>
                </div>
            </div>
        </div>
        
        <div id="gallery" class="content-section interactive">
            <div class="content-inner">
                <div class="text-block">
                    <h2>殘留物</h2>
                    <p>影像載入中...</p>
                </div>
            </div>
        </div>
    </div>

    <audio id="bg-music" loop>
        <source src="bgm.mp3" type="audio/mpeg">
    </audio>

    <script>
        let scene, camera, renderer;
        let particles, cloudParticles;
        let mouse = new THREE.Vector2();
        let raycaster;
        let clock = new THREE.Clock();

        // 參數設定
        const PARTICLE_COUNT = 3000; // 活躍粒子數量 (大幅增加)
        const CLOUD_COUNT = 50;      // 背景霧氣數量
        
        function init() {
            const container = document.getElementById('canvas-container');
            
            // 1. 場景設置
            scene = new THREE.Scene();
            // 使用深色霧氣創造景深
            scene.fog = new THREE.FogExp2(0x000000, 0.001);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 3000);
            camera.position.z = 600;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            // 2. 創建材質
            const dotSprite = getDotSprite();
            const cloudSprite = getCloudSprite();

            // 3. 系統 A: 活躍神經粒子 (Active Neurons)
            const pGeometry = new THREE.BufferGeometry();
            const positions = [];
            const randoms = []; // 用來存儲每個粒子的隨機特性，讓它們閃爍頻率不同
            const sizes = [];   // 大小不一

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                // 使用球體分佈而不是立方體，讓視覺更像一團星雲
                const r = 800 * Math.cbrt(Math.random()); // 半徑分佈
                const theta = Math.random() * 2 * Math.PI;
                const phi = Math.acos(2 * Math.random() - 1);
                
                const x = r * Math.sin(phi) * Math.cos(theta);
                const y = r * Math.sin(phi) * Math.sin(theta);
                const z = r * Math.cos(phi);

                positions.push(x, y, z);
                randoms.push(Math.random()); 
                sizes.push(Math.random() * 2 + 0.5); // 0.5 ~ 2.5
            }

            pGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            pGeometry.setAttribute('aRandom', new THREE.Float32BufferAttribute(randoms, 1));
            pGeometry.setAttribute('aSize', new THREE.Float32BufferAttribute(sizes, 1));

            // 自定義 Shader 材質 (為了讓粒子有呼吸感)
            // 這裡使用簡單的 PointsMaterial 搭配動畫模擬
            const pMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 3,
                map: dotSprite,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                transparent: true,
                opacity: 0.8,
                sizeAttenuation: true
            });

            particles = new THREE.Points(pGeometry, pMaterial);
            // 儲存原始位置以便計算流動
            particles.geometry.userData = { originalPositions: positions.slice() };
            scene.add(particles);

            // 4. 系統 B: 背景霧氣 (Chaos/Fog)
            // 這些是巨大、緩慢的煙霧
            const cGeometry = new THREE.BufferGeometry();
            const cPositions = [];
            
            for(let i=0; i<CLOUD_COUNT; i++) {
                const x = (Math.random() - 0.5) * 1500;
                const y = (Math.random() - 0.5) * 800;
                const z = (Math.random() - 0.5) * 1000 - 200; // 稍微放後面一點
                cPositions.push(x, y, z);
            }
            cGeometry.setAttribute('position', new THREE.Float32BufferAttribute(cPositions, 3));
            
            const cMaterial = new THREE.PointsMaterial({
                size: 400, // 非常大
                map: cloudSprite,
                transparent: true,
                opacity: 0.08, // 非常淡
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            
            cloudParticles = new THREE.Points(cGeometry, cMaterial);
            scene.add(cloudParticles);


            // 5. 事件
            raycaster = new THREE.Raycaster();
            document.addEventListener('mousemove', onDocumentMouseMove, false);
            window.addEventListener('resize', onWindowResize, false);

            animate();
        }

        // 產生銳利的發光點
        function getDotSprite() {
            const canvas = document.createElement('canvas');
            canvas.width = 16;
            canvas.height = 16;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(8,8,0, 8,8,8);
            grad.addColorStop(0, 'rgba(255,255,255,1)');
            grad.addColorStop(0.4, 'rgba(200,200,255,0.5)');
            grad.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0,0,16,16);
            return new THREE.CanvasTexture(canvas);
        }

        // 產生柔和的霧氣團
        function getCloudSprite() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(32,32,0, 32,32,32);
            grad.addColorStop(0, 'rgba(100,100,100,1)'); // 灰色調
            grad.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0,0,64,64);
            return new THREE.CanvasTexture(canvas);
        }

        function onDocumentMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();

            // --- 1. 更新活躍粒子 (流體運動) ---
            const positions = particles.geometry.attributes.position.array;
            const originalPositions = particles.geometry.userData.originalPositions;
            const randoms = particles.geometry.attributes.aRandom.array;
            
            // 計算滑鼠在世界空間的位置 (大概值)
            const mousePos3D = new THREE.Vector3(mouse.x, mouse.y, 0.5);
            mousePos3D.unproject(camera);
            const dir = mousePos3D.sub(camera.position).normalize();
            const distance = -camera.position.z / dir.z; // 投影到 z=0 平面
            const target = camera.position.clone().add(dir.multiplyScalar(distance));

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const px = originalPositions[i * 3];
                const py = originalPositions[i * 3 + 1];
                const pz = originalPositions[i * 3 + 2];
                
                // 有機波動：每個粒子根據自己的位置有不同的波形移動
                // 這是模擬「脈絡的自然浮動」
                const waveX = Math.sin(py * 0.002 + time * 0.5 + randoms[i] * 10) * 10;
                const waveY = Math.cos(px * 0.002 + time * 0.3 + randoms[i] * 10) * 10;
                
                // 滑鼠互動：距離滑鼠越近，擾動越大 (攪動意義場)
                let mx = positions[i*3];
                let my = positions[i*3+1];
                
                // 簡單的距離檢測
                const dx = mx - target.x;
                const dy = my - target.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                let repelX = 0;
                let repelY = 0;

                // 200單位內產生互動
                if (dist < 200) {
                    const force = (200 - dist) / 200;
                    // 這裡做一個漩渦效果：根據角度旋轉
                    repelX = dx * force * 0.05 + Math.sin(time * 5) * 2;
                    repelY = dy * force * 0.05 + Math.cos(time * 5) * 2;
                }

                // 最終位置 = 原始位置 + 自然波動 + 滑鼠擾動
                positions[i * 3]     = px + waveX + repelX;
                positions[i * 3 + 1] = py + waveY + repelY;
                positions[i * 3 + 2] = pz; // Z軸保持相對穩定，製造層次感
            }
            particles.geometry.attributes.position.needsUpdate = true;
            
            // 微微旋轉整個活躍層
            particles.rotation.y = time * 0.02;

            // --- 2. 更新背景霧氣 (極緩慢) ---
            cloudParticles.rotation.z = time * 0.01;
            cloudParticles.rotation.x = Math.sin(time * 0.05) * 0.1;

            renderer.render(scene, camera);
        }

        // --- 頁面邏輯 ---
        document.getElementById('enter-btn').addEventListener('click', () => {
            const audio = document.getElementById('bg-music');
            audio.volume = 0.8;
            audio.play().catch(e => console.log("Audio needed user interaction"));

            gsap.to('#landing-screen', { duration: 1.5, opacity: 0, pointerEvents: 'none' });
            gsap.to('nav', { duration: 1.5, opacity: 1, x: 0, delay: 0.5 });
            
            // 相機推進穿過雲層
            gsap.to(camera.position, { duration: 4, z: 200, ease: "power2.inOut" });
        });

        window.navigateTo = function(id) {
            document.querySelectorAll('.content-section').forEach(el => {
                el.classList.remove('active');
                gsap.to(el, { opacity: 0, duration: 0.5 });
            });
            
            document.querySelectorAll('.nav-link').forEach(el => el.classList.remove('active'));
            event.target.classList.add('active');

            const target = document.getElementById(id);
            target.classList.add('active');
            gsap.to(target, { opacity: 1, duration: 1, delay: 0.5 });

            // 切換頁面時，粒子場做一個比較大的擾動
             gsap.fromTo(particles.rotation, 
                { x: Math.random() * 0.5 }, 
                { x: 0, duration: 3, ease: "elastic.out(1, 0.3)" }
            );
        }

        init();
    </script>
</body>
</html>
