<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PO-HAO TSENG | 意義場 V2</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>
    <style>
        :root {
            --bg-color: #050505; /* 更深的黑，讓光暈更明顯 */
            --text-color: #dcdcdc;
            --accent-color: #a0a0a0;
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: var(--bg-color);
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; /* 改用無襯線體，更乾淨 */
            color: var(--text-color);
        }

        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        #ui-layer {
            position: relative;
            z-index: 10;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .interactive {
            pointer-events: auto;
        }

        /* Landing Screen */
        #landing-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: radial-gradient(circle, rgba(5,5,5,0) 0%, rgba(5,5,5,0.8) 100%);
            transition: opacity 1.5s ease;
        }

        h1 {
            font-weight: 200;
            letter-spacing: 8px;
            font-size: 1.2rem;
            margin-bottom: 3rem;
            text-transform: uppercase;
            opacity: 0.8;
        }

        #enter-btn {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: var(--text-color);
            padding: 15px 50px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.5s ease;
            letter-spacing: 3px;
            border-radius: 2px;
            backdrop-filter: blur(5px);
        }

        #enter-btn:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(255, 255, 255, 0.6);
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.1);
        }

        /* Navigation */
        nav {
            position: absolute;
            top: 40px;
            right: 50px;
            display: flex;
            gap: 40px;
            opacity: 0;
            transform: translateY(-20px);
        }

        .nav-link {
            text-decoration: none;
            color: #666;
            font-size: 0.85rem;
            letter-spacing: 1px;
            cursor: pointer;
            transition: color 0.4s;
            position: relative;
        }

        .nav-link:hover, .nav-link.active {
            color: #fff;
        }

        .nav-link::after {
            content: '';
            position: absolute;
            bottom: -5px;
            left: 0;
            width: 0%;
            height: 1px;
            background: #fff;
            transition: width 0.3s;
        }

        .nav-link:hover::after, .nav-link.active::after {
            width: 100%;
        }

        /* Content Sections */
        .content-section {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            opacity: 0;
            pointer-events: none; /* 預設不擋住背景 */
        }
        
        .content-section.active {
            display: block;
            pointer-events: auto;
        }

        .content-inner {
            position: absolute;
            top: 50%;
            left: 10%; /* 靠左排版，讓右邊留給意義場 */
            transform: translateY(-50%);
            width: 40%;
            max-width: 500px;
            padding: 40px;
            background: linear-gradient(90deg, rgba(0,0,0,0.8) 0%, rgba(0,0,0,0) 100%);
            border-left: 1px solid rgba(255,255,255,0.1);
        }

        .text-block p {
            line-height: 1.8;
            font-size: 0.95rem;
            color: #ccc;
            margin-bottom: 20px;
            text-align: justify;
        }

        .text-block h2 {
            font-weight: 300;
            font-size: 1.5rem;
            margin-bottom: 30px;
            color: #fff;
        }

        /* 標記強調 */
        .highlight {
            color: #fff;
            border-bottom: 1px solid #555;
        }

        @media (max-width: 768px) {
            .content-inner {
                width: 80%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0,0,0,0.85);
            }
            nav {
                width: 100%;
                right: 0;
                justify-content: center;
                background: rgba(0,0,0,0.9);
                padding: 15px 0;
            }
        }
    </style>
</head>
<body>

    <div id="canvas-container"></div>

    <div id="ui-layer">
        <div id="landing-screen" class="interactive">
            <h1>PO-HAO TSENG</h1>
            <button id="enter-btn">ENTER FIELD</button>
        </div>

        <nav id="main-nav" class="interactive">
            <a class="nav-link" onclick="navigateTo('about')">ABOUT</a>
            <a class="nav-link" onclick="navigateTo('experiences')">EXPERIENCES</a>
            <a class="nav-link" onclick="navigateTo('gallery')">GALLERY</a>
        </nav>

        <div id="about" class="content-section interactive">
            <div class="content-inner">
                <div class="text-block">
                    <h2>意義場行動表演法</h2>
                    <p>角色、語言、環境與時間皆為<span class="highlight">可變參數</span>。</p>
                    <p>我們不追求穩定的詮釋，而是在多重脈絡交會中，尋找<span class="highlight">即時生成的結構</span>。</p>
                    <p>當多條脈絡在行動中反覆交會，其重疊密度將自然產生結構上的合理性。演員的任務不在於「理解角色」，而在於辨認、延續或偏移這些交會所形成的路徑。</p>
                </div>
            </div>
        </div>

        <div id="experiences" class="content-section interactive">
            <div class="content-inner">
                <div class="text-block">
                    <h2>經歷 / Contexts</h2>
                    <p><strong>2026</strong> | 未命名的結構測試 [台北]</p>
                    <p><strong>2025</strong> | 湧現的邊界 [台南藝術節]</p>
                    <p><strong>2023</strong> | 駐村藝術家, 巴黎西帖國際藝術村</p>
                    <p><strong>2022</strong> | 導演, 《虛構的重力》</p>
                </div>
            </div>
        </div>

        <div id="gallery" class="content-section interactive">
            <div class="content-inner">
                <div class="text-block">
                    <h2>作品 / Traces</h2>
                    <p>（此區域將呈現作品的視覺殘留）</p>
                </div>
            </div>
        </div>
    </div>

    <audio id="bg-music" loop>
        <source src="bgm.mp3" type="audio/mpeg">
    </audio>

    <script>
        let scene, camera, renderer, particles;
        let positions, velocities;
        let raycaster, mouse;
        let lineGeometry, linesMesh;
        
        // 參數設定
        const PARTICLE_COUNT = 1500; // 粒子數量
        const CONNECTION_DIST = 40;  // 連線觸發距離
        const MOUSE_DIST = 150;      // 滑鼠影響範圍

        function init() {
            const container = document.getElementById('canvas-container');
            
            scene = new THREE.Scene();
            // 霧氣：讓遠處的粒子消失在深處
            scene.fog = new THREE.FogExp2(0x050505, 0.0015);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 2000);
            camera.position.z = 400;

            renderer = new THREE.WebGLRenderer({ alpha: false, antialias: true }); // alpha false 效能較好
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            // 1. 建立「霧狀」材質 (程式生成漸層圓點，不需外部圖片)
            const sprite = getSprite();
            
            // 2. 建立粒子系統
            const geometry = new THREE.BufferGeometry();
            positions = [];
            velocities = [];

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                // 隨機分佈在廣大空間
                const x = (Math.random() - 0.5) * 1000;
                const y = (Math.random() - 0.5) * 800;
                const z = (Math.random() - 0.5) * 800;
                positions.push(x, y, z);

                // 每個粒子有自己的漂浮速度 (模擬意識流動)
                velocities.push({
                    x: (Math.random() - 0.5) * 0.3,
                    y: (Math.random() - 0.5) * 0.3,
                    z: (Math.random() - 0.5) * 0.3
                });
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));

            const material = new THREE.PointsMaterial({
                color: 0x88ccff, // 微微的冷光藍白
                size: 8,         // 粒子較大但模糊
                map: sprite,     // 使用漸層材質
                blending: THREE.AdditiveBlending, // 重點：疊加混合模式！重疊處會變亮
                depthWrite: false, // 關閉深度寫入，避免遮擋問題
                transparent: true,
                opacity: 0.6
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);

            // 3. 建立連線系統 (模擬神經網絡)
            // 我們先建立一個空的 BufferGeometry，每幀更新
            lineGeometry = new THREE.BufferGeometry();
            const lineMaterial = new THREE.LineBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.15,
                blending: THREE.AdditiveBlending
            });
            linesMesh = new THREE.LineSegments(lineGeometry, lineMaterial);
            scene.add(linesMesh);

            // 4. 互動
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2(9999, 9999); // 初始滑鼠在畫布外

            document.addEventListener('mousemove', onDocumentMouseMove, false);
            window.addEventListener('resize', onWindowResize, false);

            animate();
        }

        // 程式生成圓形漸層貼圖 (替代方塊)
        function getSprite() {
            const canvas = document.createElement('canvas');
            canvas.width = 32;
            canvas.height = 32;
            const context = canvas.getContext('2d');
            const gradient = context.createRadialGradient(16, 16, 0, 16, 16, 16);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.2, 'rgba(255,255,255,0.6)');
            gradient.addColorStop(0.5, 'rgba(255,255,255,0.1)');
            gradient.addColorStop(1, 'rgba(0,0,0,0)');
            context.fillStyle = gradient;
            context.fillRect(0, 0, 32, 32);
            
            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            return texture;
        }

        function onDocumentMouseMove(event) {
            event.preventDefault();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }

        function animate() {
            requestAnimationFrame(animate);

            // 1. 更新粒子位置 (有機漂浮)
            const positionsArray = particles.geometry.attributes.position.array;
            
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                let ix = i * 3;
                let iy = i * 3 + 1;
                let iz = i * 3 + 2;

                // 加上速度
                positionsArray[ix] += velocities[i].x;
                positionsArray[iy] += velocities[i].y;
                positionsArray[iz] += velocities[i].z;

                // 邊界檢查 (如果飄太遠就瞬移回對面，形成無限循環)
                if (positionsArray[ix] > 500) positionsArray[ix] = -500;
                if (positionsArray[ix] < -500) positionsArray[ix] = 500;
                if (positionsArray[iy] > 400) positionsArray[iy] = -400;
                if (positionsArray[iy] < -400) positionsArray[iy] = 400;
            }
            particles.geometry.attributes.position.needsUpdate = true;

            // 2. 緩慢旋轉整個場域 (宇宙感)
            particles.rotation.y += 0.0005;

            // 3. 計算連線 (神經網絡 / 意義生成)
            // 為了效能，我們只計算「滑鼠附近」的粒子之間的連線
            // 這象徵「表演者的行動」觸發了意義的連結
            
            // 更新 Raycaster
            raycaster.setFromCamera(mouse, camera);
            // 找到滑鼠射線穿過的附近區域
            // 這裡我們簡化：將滑鼠投影到 Z=0 平面，計算它與粒子的距離
            
            const mousePos3D = new THREE.Vector3(mouse.x, mouse.y, 0.5);
            mousePos3D.unproject(camera);
            const dir = mousePos3D.sub(camera.position).normalize();
            const distance = -camera.position.z / dir.z;
            const targetPos = camera.position.clone().add(dir.multiplyScalar(distance));
            
            // 尋找附近的粒子並建立連線
            const linePositions = [];
            const p1 = new THREE.Vector3();
            const p2 = new THREE.Vector3();

            // 限制：只檢查部分粒子或優化算法（全檢查太慢）
            // 這裡做一個視覺近似：如果粒子靠近滑鼠投影點，且彼此靠近，就連線
            
            // 由於效能考量，我們在JS中做簡易距離判斷
            // 把粒子座標轉為世界座標有點慢，這裡我們假設粒子系統旋轉不大
            
            let connectCount = 0;
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const ix = i * 3;
                p1.set(positionsArray[ix], positionsArray[ix+1], positionsArray[ix+2]);
                
                // 應用粒子系統的旋轉
                p1.applyEuler(particles.rotation);

                // 如果粒子距離滑鼠指出的點很近 (Meaning Field Activation)
                if (p1.distanceTo(targetPos) < MOUSE_DIST) {
                    
                    // 讓這個粒子稍微被滑鼠吸引 (互動)
                    // positionsArray[ix] += (targetPos.x - p1.x) * 0.01; // 這樣會破壞 buffer array，暫時不做物理吸引
                    
                    // 尋找它的鄰居
                    for (let j = i + 1; j < PARTICLE_COUNT; j++) {
                        const jx = j * 3;
                        p2.set(positionsArray[jx], positionsArray[jx+1], positionsArray[jx+2]);
                        p2.applyEuler(particles.rotation);

                        if (p2.distanceTo(targetPos) < MOUSE_DIST) {
                            if (p1.distanceTo(p2) < CONNECTION_DIST) {
                                linePositions.push(p1.x, p1.y, p1.z);
                                linePositions.push(p2.x, p2.y, p2.z);
                                connectCount++;
                                if(connectCount > 500) break; // 限制連線數量上限，保護效能
                            }
                        }
                    }
                }
            }
            
            lineGeometry.setAttribute('position', new THREE.Float32BufferAttribute(linePositions, 3));

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- 頁面邏輯 ---
        document.getElementById('enter-btn').addEventListener('click', () => {
            const audio = document.getElementById('bg-music');
            audio.volume = 0.8;
            audio.play().catch(e => console.log("Audio needed user interaction"));

            gsap.to('#landing-screen', { duration: 2, opacity: 0, pointerEvents: 'none' });
            gsap.to('nav', { duration: 1.5, opacity: 1, y: 0, delay: 1 });
            
            // 相機推進，進入意義場
            gsap.to(camera.position, { duration: 4, z: 200, ease: "power2.inOut" });
        });

        window.navigateTo = function(id) {
            // 隱藏舊內容
            document.querySelectorAll('.content-section').forEach(el => {
                el.classList.remove('active');
                gsap.to(el, { opacity: 0, duration: 0.5 });
            });
            
            // 更新選單
            document.querySelectorAll('.nav-link').forEach(el => el.classList.remove('active'));
            event.target.classList.add('active');

            // 顯示新內容
            const target = document.getElementById(id);
            target.classList.add('active');
            gsap.to(target, { opacity: 1, duration: 1, delay: 0.5 });

            // 視覺回饋：切換頁面時，粒子場做一個 "擾動"
            // 這裡簡單用相機位置偏移來模擬
            const randomX = (Math.random() - 0.5) * 50;
            const randomY = (Math.random() - 0.5) * 50;
            gsap.to(camera.position, { x: randomX, y: randomY, duration: 2, ease: "power2.out" });
        }

        init();
    </script>
</body>
</html>
